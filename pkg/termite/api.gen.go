//go:build go1.22

// Package termite provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package termite

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	externalRef0 "github.com/antflydb/antfly-go/libaf/chunking"
	externalRef1 "github.com/antflydb/antfly-go/libaf/logging"
	externalRef2 "github.com/antflydb/antfly-go/libaf/s3"
	externalRef3 "github.com/antflydb/antfly-go/libaf/scraping"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
)

// Defines values for ConfigModelStrategies.
const (
	ConfigModelStrategiesBounded ConfigModelStrategies = "bounded"
	ConfigModelStrategiesEager   ConfigModelStrategies = "eager"
	ConfigModelStrategiesLazy    ConfigModelStrategies = "lazy"
)

// Defines values for ImageURLContentPartType.
const (
	ImageURLContentPartTypeImageUrl ImageURLContentPartType = "image_url"
)

// Defines values for TextContentPartType.
const (
	TextContentPartTypeText TextContentPartType = "text"
)

// Chunk A chunk of text with position information.
type Chunk = externalRef0.Chunk

// ChunkConfig Configuration for chunking requests to Termite API.
// This is a simplified config for the HTTP API - differs from the full ChunkerConfig
// which includes provider selection and caching configuration.
type ChunkConfig struct {
	// MaxChunks Maximum number of chunks to return
	MaxChunks int `json:"max_chunks,omitempty,omitzero"`

	// Model The chunking model to use. Either 'fixed' for simple token-based chunking, or a model name from models/chunkers/{name}/.
	Model string `json:"model,omitempty,omitzero"`

	// OverlapTokens Number of overlapping tokens between chunks
	OverlapTokens int `json:"overlap_tokens,omitempty,omitzero"`

	// Separator Text separator for fixed chunking
	Separator string `json:"separator,omitempty,omitzero"`

	// TargetTokens Target number of tokens per chunk
	TargetTokens int `json:"target_tokens,omitempty,omitzero"`

	// Threshold Confidence threshold for ONNX models (0.0-1.0)
	Threshold float32 `json:"threshold,omitempty,omitzero"`
}

// ChunkRequest defines model for ChunkRequest.
type ChunkRequest struct {
	// Config Configuration for chunking requests to Termite API.
	// This is a simplified config for the HTTP API - differs from the full ChunkerConfig
	// which includes provider selection and caching configuration.
	Config ChunkConfig `json:"config,omitempty,omitzero"`

	// Text Text to chunk
	Text string `json:"text"`
}

// ChunkResponse defines model for ChunkResponse.
type ChunkResponse struct {
	// CacheHit Whether result was served from cache
	CacheHit bool `json:"cache_hit"`

	// Chunks Array of text chunks
	Chunks []Chunk `json:"chunks"`

	// ModelUsed Chunking model actually used (may differ from requested if fallback occurred)
	ModelUsed string `json:"model_used"`
}

// Config defines model for Config.
type Config struct {
	// ApiUrl URL of the Termite embedding/chunking service
	ApiUrl string `json:"api_url"`

	// ChunkerModelsDir Directory containing chunker ONNX models. Termite will discover and load all models in this directory (similar to Ollama). If not set, only built-in 'fixed' chunking is available.
	ChunkerModelsDir string                             `json:"chunker_models_dir,omitempty,omitzero"`
	ContentSecurity  externalRef3.ContentSecurityConfig `json:"content_security,omitempty,omitzero"`

	// EmbedderModelsDir Directory containing embedder ONNX models. Termite will discover and load all models in this directory (similar to Ollama). If not set, embedding endpoint will not be available.
	EmbedderModelsDir string `json:"embedder_models_dir,omitempty,omitzero"`

	// Gpu GPU acceleration mode:
	// - "auto": Auto-detect GPU availability (default). Uses CUDA on Linux if nvidia-smi is available, CoreML on macOS.
	// - "true": Force GPU on. Will fail at runtime if GPU is not available.
	// - "false": Force GPU off (CPU only).
	//
	// On macOS, CoreML is always used when available (no configuration needed).
	// On Linux, CUDA is auto-detected via nvidia-smi or CUDA library presence.
	// Legacy env var ANTFLY_USE_CUDA=1 still works but this config takes precedence.
	Gpu string `json:"gpu,omitempty,omitzero"`

	// KeepAlive How long to keep models loaded in memory after last use (Ollama-compatible).
	// Models are automatically unloaded after this duration of inactivity.
	// Use Go duration format: "5m" (5 minutes), "1h" (1 hour), "0" (never unload, eager loading).
	// When set to "0" or omitted, models are loaded eagerly at startup and never unloaded (legacy behavior).
	KeepAlive string `json:"keep_alive,omitempty,omitzero"`

	// Log Logging configuration for Termite services
	Log externalRef1.Config `json:"log,omitempty,omitzero"`

	// MaxConcurrentRequests Maximum number of concurrent inference requests allowed.
	// Additional requests will be queued up to max_queue_size.
	// Set to 0 for unlimited (default).
	MaxConcurrentRequests int `json:"max_concurrent_requests,omitempty,omitzero"`

	// MaxLoadedModels Maximum number of models to keep loaded in memory simultaneously.
	// When this limit is reached, the least recently used model is unloaded (LRU eviction).
	// Set to 0 for unlimited (default). Only effective when keep_alive is non-zero.
	MaxLoadedModels int `json:"max_loaded_models,omitempty,omitzero"`

	// MaxMemoryMb Maximum memory (in MB) to use for loaded models.
	// When this limit is approached, least recently used models are unloaded.
	// Set to 0 for unlimited (default). This is an advisory limit - actual memory
	// usage depends on model sizes and may temporarily exceed this value.
	// Works alongside max_loaded_models for fine-grained control.
	MaxMemoryMb int `json:"max_memory_mb,omitempty,omitzero"`

	// MaxQueueSize Maximum number of requests to queue when max_concurrent_requests is reached.
	// When the queue is full, new requests receive 503 Service Unavailable with Retry-After header.
	// Set to 0 for unlimited queue (default). Only effective when max_concurrent_requests > 0.
	MaxQueueSize int `json:"max_queue_size,omitempty,omitzero"`

	// ModelStrategies Per-model loading strategy overrides. Maps model names to their loading strategy.
	// Models not in this map use the default strategy based on keep_alive:
	// - If keep_alive="0" (default): eager loading (load at startup, never unload)
	// - If keep_alive>0: lazy loading (load on demand, unload after idle)
	//
	// When a model has strategy "eager" in this map:
	// - It is loaded at startup (as part of preload)
	// - It is never unloaded, even when keep_alive>0 (pinned in memory)
	//
	// This allows mixing eager and lazy models in the same pool.
	ModelStrategies map[string]ConfigModelStrategies `json:"model_strategies,omitempty,omitzero"`

	// Preload List of model names to preload at startup (Ollama-compatible).
	// These models are loaded immediately when Termite starts, avoiding first-request latency.
	// Model names should match those in embedder_models_dir (e.g., "bge-small-en-v1.5").
	// Only effective when keep_alive is non-zero (lazy loading mode).
	Preload []string `json:"preload,omitempty,omitzero"`

	// RequestTimeout Maximum time to wait for a request to complete, including queue wait time.
	// Use Go duration format: "30s", "1m", "0" (no timeout, default).
	// Requests exceeding this timeout receive 504 Gateway Timeout.
	RequestTimeout string `json:"request_timeout,omitempty,omitzero"`

	// RerankerModelsDir Directory containing reranker ONNX models. Termite will discover and load all models in this directory (similar to Ollama). If not set, reranking endpoint will not be available.
	RerankerModelsDir string                   `json:"reranker_models_dir,omitempty,omitzero"`
	S3Credentials     externalRef2.Credentials `json:"s3_credentials,omitempty,omitzero"`
}

// ConfigModelStrategies defines model for Config.ModelStrategies.
type ConfigModelStrategies string

// ContentPart A content part for multimodal embedding (text or image)
type ContentPart struct {
	union json.RawMessage
}

// EmbedRequest defines model for EmbedRequest.
type EmbedRequest struct {
	// Input Input content to embed. Supports three formats:
	// - Single text string: `"hello world"`
	// - Array of text strings: `["hello", "world"]`
	// - Array of content parts (multimodal): `[{"type": "text", "text": "hello"}, {"type": "image_url", "image_url": {"url": "data:image/png;base64,..."}}]`
	Input EmbedRequest_Input `json:"input"`

	// Model Name of the embedder model from embedder_models_dir
	Model string `json:"model"`

	// Truncate Truncate input to fit model context length
	Truncate bool `json:"truncate,omitempty,omitzero"`
}

// EmbedRequestInput0 Single text string (backward compatible)
type EmbedRequestInput0 = string

// EmbedRequestInput1 Array of text strings (backward compatible)
type EmbedRequestInput1 = []string

// EmbedRequestInput2 Array of multimodal content parts (text or images)
type EmbedRequestInput2 = []ContentPart

// EmbedRequest_Input Input content to embed. Supports three formats:
// - Single text string: `"hello world"`
// - Array of text strings: `["hello", "world"]`
// - Array of content parts (multimodal): `[{"type": "text", "text": "hello"}, {"type": "image_url", "image_url": {"url": "data:image/png;base64,..."}}]`
type EmbedRequest_Input struct {
	union json.RawMessage
}

// EmbedResponse defines model for EmbedResponse.
type EmbedResponse struct {
	// Embeddings Array of embedding vectors (one per input string)
	Embeddings [][]float32 `json:"embeddings"`

	// Model Model used for embedding
	Model string `json:"model"`
}

// Error defines model for Error.
type Error struct {
	// Error Error message
	Error string `json:"error"`
}

// ImageURL Image URL or data URI
type ImageURL struct {
	// Url URL or data URI (data:image/png;base64,...)
	Url string `json:"url"`
}

// ImageURLContentPart Image content for embedding (OpenAI-compatible format)
type ImageURLContentPart struct {
	// ImageUrl Image URL or data URI
	ImageUrl ImageURL                `json:"image_url"`
	Type     ImageURLContentPartType `json:"type"`
}

// ImageURLContentPartType defines model for ImageURLContentPart.Type.
type ImageURLContentPartType string

// ModelsResponse defines model for ModelsResponse.
type ModelsResponse struct {
	// Chunkers Available chunking models (always includes "fixed")
	Chunkers []string `json:"chunkers"`

	// Embedders Available embedding models from embedder_models_dir
	Embedders []string `json:"embedders"`

	// Rerankers Available reranking models
	Rerankers []string `json:"rerankers"`
}

// RerankRequest defines model for RerankRequest.
type RerankRequest struct {
	// Model Name of reranking model from `reranker_models_dir`
	Model string `json:"model"`

	// Prompts Pre-rendered document texts to rerank. The client is responsible for extracting
	// and rendering document fields/templates before calling this endpoint.
	Prompts []string `json:"prompts"`

	// Query Search query for relevance scoring
	Query string `json:"query"`
}

// RerankResponse defines model for RerankResponse.
type RerankResponse struct {
	// Model Name of model used for reranking
	Model string `json:"model"`

	// Scores Relevance scores (one per prompt, same order as input)
	Scores []float32 `json:"scores"`
}

// TextContentPart Text content for embedding
type TextContentPart struct {
	// Text Text content to embed
	Text string              `json:"text"`
	Type TextContentPartType `json:"type"`
}

// TextContentPartType defines model for TextContentPart.Type.
type TextContentPartType string

// VersionResponse defines model for VersionResponse.
type VersionResponse struct {
	// BuildTime Build timestamp
	BuildTime string `json:"build_time"`

	// GitCommit Git commit hash
	GitCommit string `json:"git_commit"`

	// GoVersion Go runtime version
	GoVersion string `json:"go_version"`

	// Version Termite version
	Version string `json:"version"`
}

// ChunkTextJSONRequestBody defines body for ChunkText for application/json ContentType.
type ChunkTextJSONRequestBody = ChunkRequest

// GenerateEmbeddingsJSONRequestBody defines body for GenerateEmbeddings for application/json ContentType.
type GenerateEmbeddingsJSONRequestBody = EmbedRequest

// RerankPromptsJSONRequestBody defines body for RerankPrompts for application/json ContentType.
type RerankPromptsJSONRequestBody = RerankRequest

// AsTextContentPart returns the union data inside the ContentPart as a TextContentPart
func (t ContentPart) AsTextContentPart() (TextContentPart, error) {
	var body TextContentPart
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTextContentPart overwrites any union data inside the ContentPart as the provided TextContentPart
func (t *ContentPart) FromTextContentPart(v TextContentPart) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTextContentPart performs a merge with any union data inside the ContentPart, using the provided TextContentPart
func (t *ContentPart) MergeTextContentPart(v TextContentPart) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsImageURLContentPart returns the union data inside the ContentPart as a ImageURLContentPart
func (t ContentPart) AsImageURLContentPart() (ImageURLContentPart, error) {
	var body ImageURLContentPart
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromImageURLContentPart overwrites any union data inside the ContentPart as the provided ImageURLContentPart
func (t *ContentPart) FromImageURLContentPart(v ImageURLContentPart) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeImageURLContentPart performs a merge with any union data inside the ContentPart, using the provided ImageURLContentPart
func (t *ContentPart) MergeImageURLContentPart(v ImageURLContentPart) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ContentPart) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ContentPart) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsEmbedRequestInput0 returns the union data inside the EmbedRequest_Input as a EmbedRequestInput0
func (t EmbedRequest_Input) AsEmbedRequestInput0() (EmbedRequestInput0, error) {
	var body EmbedRequestInput0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEmbedRequestInput0 overwrites any union data inside the EmbedRequest_Input as the provided EmbedRequestInput0
func (t *EmbedRequest_Input) FromEmbedRequestInput0(v EmbedRequestInput0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEmbedRequestInput0 performs a merge with any union data inside the EmbedRequest_Input, using the provided EmbedRequestInput0
func (t *EmbedRequest_Input) MergeEmbedRequestInput0(v EmbedRequestInput0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEmbedRequestInput1 returns the union data inside the EmbedRequest_Input as a EmbedRequestInput1
func (t EmbedRequest_Input) AsEmbedRequestInput1() (EmbedRequestInput1, error) {
	var body EmbedRequestInput1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEmbedRequestInput1 overwrites any union data inside the EmbedRequest_Input as the provided EmbedRequestInput1
func (t *EmbedRequest_Input) FromEmbedRequestInput1(v EmbedRequestInput1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEmbedRequestInput1 performs a merge with any union data inside the EmbedRequest_Input, using the provided EmbedRequestInput1
func (t *EmbedRequest_Input) MergeEmbedRequestInput1(v EmbedRequestInput1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEmbedRequestInput2 returns the union data inside the EmbedRequest_Input as a EmbedRequestInput2
func (t EmbedRequest_Input) AsEmbedRequestInput2() (EmbedRequestInput2, error) {
	var body EmbedRequestInput2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEmbedRequestInput2 overwrites any union data inside the EmbedRequest_Input as the provided EmbedRequestInput2
func (t *EmbedRequest_Input) FromEmbedRequestInput2(v EmbedRequestInput2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEmbedRequestInput2 performs a merge with any union data inside the EmbedRequest_Input, using the provided EmbedRequestInput2
func (t *EmbedRequest_Input) MergeEmbedRequestInput2(v EmbedRequestInput2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t EmbedRequest_Input) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *EmbedRequest_Input) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Chunk text into smaller segments
	// (POST /chunk)
	ChunkText(w http.ResponseWriter, r *http.Request)
	// Generate embeddings
	// (POST /embed)
	GenerateEmbeddings(w http.ResponseWriter, r *http.Request)
	// List available models
	// (GET /models)
	ListModels(w http.ResponseWriter, r *http.Request)
	// Rerank prompts by relevance
	// (POST /rerank)
	RerankPrompts(w http.ResponseWriter, r *http.Request)
	// Get version information
	// (GET /version)
	GetVersion(w http.ResponseWriter, r *http.Request)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// ChunkText operation middleware
func (siw *ServerInterfaceWrapper) ChunkText(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ChunkText(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GenerateEmbeddings operation middleware
func (siw *ServerInterfaceWrapper) GenerateEmbeddings(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GenerateEmbeddings(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListModels operation middleware
func (siw *ServerInterfaceWrapper) ListModels(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListModels(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// RerankPrompts operation middleware
func (siw *ServerInterfaceWrapper) RerankPrompts(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RerankPrompts(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetVersion operation middleware
func (siw *ServerInterfaceWrapper) GetVersion(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetVersion(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
	HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
	ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("POST "+options.BaseURL+"/chunk", wrapper.ChunkText)
	m.HandleFunc("POST "+options.BaseURL+"/embed", wrapper.GenerateEmbeddings)
	m.HandleFunc("GET "+options.BaseURL+"/models", wrapper.ListModels)
	m.HandleFunc("POST "+options.BaseURL+"/rerank", wrapper.RerankPrompts)
	m.HandleFunc("GET "+options.BaseURL+"/version", wrapper.GetVersion)

	return m
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	for rawPath, rawFunc := range externalRef0.PathToRawSpec(path.Join(path.Dir(pathToFile), "../../../antfly-go/libaf/chunking/openapi.yaml")) {
		if _, ok := res[rawPath]; ok {
			// it is not possible to compare functions in golang, so always overwrite the old value
		}
		res[rawPath] = rawFunc
	}
	for rawPath, rawFunc := range externalRef1.PathToRawSpec(path.Join(path.Dir(pathToFile), "../../../antfly-go/libaf/logging/openapi.yaml")) {
		if _, ok := res[rawPath]; ok {
			// it is not possible to compare functions in golang, so always overwrite the old value
		}
		res[rawPath] = rawFunc
	}
	for rawPath, rawFunc := range externalRef2.PathToRawSpec(path.Join(path.Dir(pathToFile), "../../../antfly-go/libaf/s3/openapi.yaml")) {
		if _, ok := res[rawPath]; ok {
			// it is not possible to compare functions in golang, so always overwrite the old value
		}
		res[rawPath] = rawFunc
	}
	for rawPath, rawFunc := range externalRef3.PathToRawSpec(path.Join(path.Dir(pathToFile), "../../../antfly-go/libaf/scraping/openapi.yaml")) {
		if _, ok := res[rawPath]; ok {
			// it is not possible to compare functions in golang, so always overwrite the old value
		}
		res[rawPath] = rawFunc
	}
	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
